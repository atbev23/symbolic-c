//
// Created by atbev on 7/12/2025.
//
#include <string.h>
#include "mem_pool_t.h"

#include <stdio.h>

void mem_pool_init(mem_pool_t* pool) {
    memset(pool->used, 0, sizeof(pool->used)); // set all used variables to false for all nodes
    pool->free_count = MAX_POOL;
}

void* mem_pool_alloc(mem_pool_t* pool) {
    if (pool->free_count == 0) return NULL;

    for (int i = 0; i < MAX_POOL; i++) {
        if (!pool->used[i]) {           // if the node isn't used
            pool->used[i] = true;       // turn it to used
            pool->free_count--;         // 1 fewer nodes are free
            //memset(&pool->nodes[i], 0, sizeof(ast_node_t));
            return &pool->items[i];     // return the allocated space
        }
    }
    return NULL;  // should not reach here
}
bool mem_pool_free_item(mem_pool_t* pool, const void* item) {

    const ptrdiff_t index = item - pool->items;             // get address to node
    if (index < 0 || index >= MAX_POOL) return false;  // check if freeing memory not in the pool
    if (!pool->used[index]) return false;                   // make sure the node isn't still in use
    // if all those checks pass:
    pool->used[index] = false;                                      // set used to false
    pool->free_count++;                                             // add one to the free nodes count
    memset(pool->items + index, 0, sizeof(void*)); // clear the memory
    return true;
}

void mem_pool_status(const mem_pool_t* pool) {
    printf("Pool usage: %d/%d nodes used\n", MAX_POOL - pool->free_count, MAX_POOL);
}